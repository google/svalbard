// Copyright 2018 The Svalbard Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////

// Messages used by Svalbard -- a system for a secure backup of secrets.
//
// Svalbard is a distributed backup system for secret data, like
// passwords, encryption keys, Bitcoin keys, etc., intended for
// long-term protection of that data.  It assures a reasonable
// confidentiality, while being also easy-to-use.  In particular, the
// scheme does not require any additional account or password, and is
// resilient against failures or compromise of components of the
// system. The system leverages the trust/identification mechanisms
// present at various components from the real world to provide a
// solution that is both usable and secure.
//
// We have three types of parties involved:
//  (a) client:
//      * computes shares of a secret, then stores the shares on share
//        storage, and metadata on cloud provider
//      * retrieves metadata from cloud provider, then retrieves shares
//        from share storage, and reconstructs the secret
//  (b) share storage:
//      * stores the shares, provides the shares for retrieval
//        (the shares are serialized protos, but are treated by
//        storage systems as opaque bitstrings, i.e. the storage systems
//        do not make explicit use of the protos defined in this file.)
//  (c) cloud provider:
//      * stores the metadata, provides the metadata for retrieval
//
// The secret sharing is in fact a 2-level sharing: first the actual
// secret is split into two random strings which XOR-ed together give
// the secret (XOR-masking), then one of the random strings is
// stored with metadata, while the other is secret-shared via a secret
// sharing scheme of choice.
//
// That is, given a secret S we proceed as follows:
//   1. First level sharing (XOR-masking):
//        (a) pick a random string secret_mask of length equal to length of S
//        (b) compute masked_S := S XOR secret_mask
//      (secret_mask, masked_S) have the property that
//            (secret_mask XOR masked_S) equals S.
//      secret_mask becomes a part of the metadata.
//
//   2. Second level sharing:
//      masked_S is secret-shared using a k-out-of-n secret sharing scheme.
//
// The two-level sharing with XOR-masking provides an extra
// protection: even if an attacker can get sufficiently many shares
// and potentially reconstruct the value they determine (which for
// some sharing types might possible withouth metadata), the
// reconstructed value is still useless (statistically independent)
// from the actual secret without the metadata.  In other words,
// neither the shares alone, nor the metadata alone, give any information
// about the secret.
//
// Main messages and their use by the parties:
//  * SharedSecretMetadata:: Generated by the client upon sharing,
//    with inputs from the user.  Stored by cloud provider.
//    Contains additionally secret_mask from XOR-masking (see above),
//    which is necessary for reconstruction of the secret.
//
//    Used by the client to compute shares, and to store them:
//      ("secret", SharedSecretMetadata) -> SharedSecret
//      (SharedSecret, SharedSecretMetada)-> shares stored according to metadata
//
//    Used by the client to collect shares and reconstruct the secret:
//      (SharedSecretMetadata) -> gather shares and construct SharedSecret
//      (SharedSecret, SharedSecretMetadata) -> reconstruct "secret"
//
//  * SharedSecret:: used by the client to share/reconstruct a secret,
//    as described above.
//
// TODO: consider adding a timestamp to stored shares or sharing scheme.

syntax = "proto3";

package svalbard;

option java_package = "com.google.security.svalbard.proto";
option java_multiple_files = true;

// ---------------------------------------------------------------------------
// Messages describing specific secret sharing schemes and their shares.

// A k-out-of-n Shamir secret sharing.
// The shares are computed at evaluation points determined by the
// integer-to-element mapping from GfDescriptor, and the secret value
// is the value of the polynomial at element 0.
//
// sharing_scheme_type:
// type.googleapis.com/com.google.security.svalbard.proto.ShamirSharingScheme
message ShamirSharingScheme {
  // Identifies the underlying Galois Field, incl. a mapping
  // between integers and field elements.
  // Required.
  string gf_id = 1;

  // Required, must satisfy 1 <= k <= n.
  int32 k = 2;

  // Required, must satisfy 1 <= n.
  int32 n = 3;
}

message ShamirShare {
  // The value of a share, in binary format.
  // Required.
  bytes value = 1;

  // Required.
  int64 share_point_index = 2;
}

// ---------------------------------------------------------------------------
// A container for actual shares of a shared secret.
// Used for managing the shares in the client code.

message SharedSecret {
  // Name of the proto that describes the secret sharing scheme.  For standard
  // sharing schemes offered by Svalbard it follows the structure of
  // type_url-field of google.protobuf.Any-protos, and is given as:
  //     type.googleapis.com/packagename.messagename
  //
  // For example, for Shamir secret sharing defined in the proto
  // com.google.security.svalbard.proto.ShamirSharingScheme the value would be
  // type.googleapis.com/com.google.security.svalbard.proto.ShamirSharingScheme
  //
  // Required.
  string sharing_scheme_type = 1;

  // Actual description of the secret sharing scheme, contains a serialized
  // proto named in the sharing_scheme_type-field.
  // Required.
  bytes sharing_scheme = 2;

  // A sequence of shares.
  // Each entry is a serialized proto that depends on the sharing scheme.
  // For example for Shamir scheme this would be ShamirShare.
  // Required.
  repeated bytes share = 3;
}

// ---------------------------------------------------------------------------
// Containers for the sharing metadata stored with cloud provider.
// They describe how shares of a secret are managed and stored.

// Types of storage location where shares can be stored.
enum LocationType {
  UNKNOWN_LOCATION_TYPE = 0;
  SVALBARD_SERVER = 1;
  PRINTED_COPY = 2;
  PEER_DEVICE = 3;
}

// Location of a single share.
message ShareLocation {
  // Required.
  LocationType location_type = 1;

  // A label determining the storage location, e.g. a server name,
  // or peer's device name.
  // Required.
  string location_name = 2;

  // A type of owner id, e.g. SMS or some other instant messaging service.
  // Required for SVALBARD_SERVER.
  string owner_id_type = 3;

  // A name of the owner, or owner's cell phone number.
  // The tuple (owner_id_type, owner_id) determines a secondary communication
  // channel for transmitting short-lived tokens for accessing the share.
  // Required for SVALBARD_SERVER.
  string owner_id = 4;
}

// Metadata of a single share.
message ShareMetadata {
  // Location where the share is stored.
  // Required.
  ShareLocation location = 1;

  // A simple salted hash for a rough checking of the validity of a retrieved share.
  // It is a SHA-256 hash over a byte array of length
  //   1 + length(hash_salt) + length(share)
  // which is constructed as follows:
  //   * the first byte contains the length of hash_salt
  //   * then the actual bytes of hash_salt follow
  //   * and finally the bytes of the share follow.
  // Required.
  bytes share_hash = 2;
}

// Metadata of an entire sharing of a single secret.
message SharedSecretMetadata {
  // The version of the metadata proto.
  // Required.
  int32 version = 1;

  // Name of the proto that describes the secret sharing scheme.  For standard
  // sharing schemes offered by Svalbard it follows the structure of
  // type_url-field of google.protobuf.Any-protos, and is given as:
  //     type.googleapis.com/packagename.messagename
  //
  // For example, for Shamir secret sharing defined in the proto
  // com.google.security.svalbard.proto.ShamirSharingScheme the value would be
  // type.googleapis.com/com.google.security.svalbard.proto.ShamirSharingScheme
  //
  // Required.
  string sharing_scheme_type = 2;

  // Actual description of the secret sharing scheme, contains a serialized
  // proto named in the sharing_scheme_type-field.
  // Required.
  bytes sharing_scheme = 3;

  // A name of the shared secret, can be picked by the user (secret owner).
  // Required.
  string secret_name = 4;

  // The mask from XOR-masking of the secret.
  // Required.
  bytes secret_mask = 5;

  // Salt used for computing share hashes, see ShareMetadata.share_hash.
  // The length of the salt must be in range 1..255.
  // Required.
  bytes hash_salt = 6;

  // A sequence of messages describing how and where the shares are stored.
  // Required.
  repeated ShareMetadata share_metadata = 7;
}
